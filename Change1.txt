Chapter 1
1.2
-- Functions in Haskell are first class meaning they can be used 
    -- as values or passed as arguments or imputs in other functions
    -- ie as HOFs.
-- All FP based on lambda calculus. Haskell is a pure FPL
    -- purity == referential transparency (RT);
        -- means the same function given the same arguments to be evaluated
        -- will always return the same results in a pure FPL just as in Math.
1.3
-- Functions are relation mechanisims between a set of
    -- possible inputs and a set of possible outputs
    -- arguments are always mapped to the parameters
        ex. ğŸ˜
                Æ’(1) = A 
                Æ’(2) = B
                Æ’(3) = C
            -- the input (domain) is set to {1,2,3} and th outputs (codomain)
            -- are {A, B, C}
        -- The most important factor is that these functions will always
            return (A) given the input (1) with no exceptions.

    ex. of invalid ğŸ˜µâ€ğŸ’«
              Æ’(1) = X
              Æ’(1) = Y
              Æ’(2) = Z
            -- this is incorrect because of the principal of RT
                the same input must produce the same output, it should be predictable
    
    -- This is valid, even though there are different inputs the outputs can have the
        same value, this is no problem

    Æ’(1) = A 
    Æ’(2) = A
    Æ’(3) = A
    -- Just as this is valid:
    Æ’ (a b) = \a b -> a(3) + b(2) = 5
    Æ’ (c d) = \c d -> c(4) + d(1) = 5
    Æ’ (e f) = \e f -> e(5) + e(0) = 5
-- The gist is the importance of the relationship betwenn the inputs and outputs,
   that once a function is given an input the output should be predictable/consistant.

-- Functions are nothing but mappings of a set of inputs to a set of outputs. 
1.4
-- Lambda calculus has three basic components/lambda terms
    1. ) expression 2.) variables 3.) abstractions
    An expression is a superset of the other 2, variables names, an abstractions or a combonation.
    -- the simplest expression is a single variable.
    -- variables have no meaning or value; they are only names for potential
        inputs in a function.
    -- and abstraction is a function. 
    -- abstractions consist of 2 parts: the head and the body.
        the head of the function is a ğº (lambda) followed by a variable name
        the body of the function is also an expression 
            a simple function might look like this:

                ğºğŒ ğŒ => is called and anonymous function (AF)

            the variable (ğŒ) name in the head (ğºğŒ)is the parameter
            and connects all the instances of the same variable in the function body.
            . each ğŒ will have the value of that argument

        -- a named function can be called by another function by an AF cannot.
    -- Alpha equivalence (AE)
        the typical expression of AE in Lambda cal:
            ğºğŒ ğŒ
        the variable is not semantically meaningful expect in the role of a 
        singular expression, this is AE.
            ğºğŒ.ğŒ
            ğºÈ¥.È¥
            ğºÉ—.É—
        these all mean the same thing, a mapping of the variable in the head with that
        in the body. 